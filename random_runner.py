#
# Random runner for the strategy language
#

import random

import umaudemc.pyslang as pysl


class RandomRunner(pysl.StratRunner):
	"""Runner that resolves every choice locally at random without backtracking.

	Instead of solutions of the strategy, the run method returns the succesive steps
	of a single random rewriting path. Hence, conditionals do no work with this runner,
	since exploration is not exhaustive."""

	def __init__(self, program, term):
		super().__init__(program, term)

	def next_pending(self):
		"""Change the current state a random pending state"""

		# If there is no pending work, the strategy is exhausted
		if not self.pending:
			self.current_state = None
			return False

		# Otherwise, a pending state is chosen at random and all other pending
		# states are discarded. Indeed, pending states are not actually pending but
		# they have just been generated by a nondeterministic instruction (rule
		# application, call, matchrew...) before calling this method. Reimplemeting
		# these instructions is avoided by this trick.
		self.current_state = random.choice(self.pending)
		self.pending.clear()

		return True

	def jump(self, args, stack):
		"""Takes a branch of the jump at random"""

		if not args:
			self.current_state = None
		else:
			self.current_state.pc = random.choice(args)

	def notify(self, args, stack):
		"""Notify the rewrite as a solution"""

		# The notion of "solution" in this execution mode is "step" or "rewrite"
		self.solution = pysl.rebuild_term(self.current_state.term, stack, args)
		self.current_state.pc += 1

	def pop(self, _, stack):
		"""Return from a strategy call or similar construct"""

		# Return from a strategy call
		if stack.pc:
			self.current_state.pc = stack.pc

		# Pop the stack node
		if stack.parent:
			self.current_state.stack = self.current_state.stack.parent

		# This is the root node, we have finished
		else:
			self.current_state = None

	def run(self):
		"""Run the strategy and get the next step"""

		self.solution = None

		while self.current_state:
			# Visited states are not tracked, we are simulating

			# The instruction to be executed
			inst = self.code[self.current_state.pc]
			self.handlers[inst.type](inst.extra, self.current_state.stack)

			if self.solution:
				return self.solution

		return None
